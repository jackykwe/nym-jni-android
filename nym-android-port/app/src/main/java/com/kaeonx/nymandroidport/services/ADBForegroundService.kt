package com.kaeonx.nymandroidport.services

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.Service
import android.content.Context
import android.content.Intent
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationCompat.FOREGROUND_SERVICE_IMMEDIATE
import com.kaeonx.nymandroidport.R
import com.kaeonx.nymandroidport.autogenerated.NEW_CLIENT_ID
import com.kaeonx.nymandroidport.database.AppDatabase
import com.kaeonx.nymandroidport.database.NYM_RUN_STATE_KSVP_KEY
import com.kaeonx.nymandroidport.database.RUNNING_CLIENT_ADDRESS_KSVP_KEY
import com.kaeonx.nymandroidport.database.RUNNING_CLIENT_ID_KSVP_KEY
import com.kaeonx.nymandroidport.jni.getAddress
import com.kaeonx.nymandroidport.jni.nymInit
import com.kaeonx.nymandroidport.jni.topLevelInit
import com.kaeonx.nymandroidport.repositories.KeyStringValuePairRepository
import com.kaeonx.nymandroidport.utils.NymRunState
import kotlinx.coroutines.*
import kotlin.system.exitProcess

private const val TAG = "adbForegroundService"
private const val ONGOING_NOTIFICATION_ID = 43

class ADBForegroundService : Service() {

    // Courtesy of <https://stackoverflow.com/a/63407811>
    private val supervisorJob by lazy { SupervisorJob() }
    private val serviceIOScope by lazy { CoroutineScope(Dispatchers.IO + supervisorJob) }

    private val keyStringValuePairRepository by lazy {
        KeyStringValuePairRepository(
            AppDatabase.getInstance(applicationContext).keyStringValuePairDao()
        )
    }

    override fun onCreate() {
        Log.i(TAG, "Hello ADB FG Service")
    }


    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Since this foreground service is started by startForegroundService(), it must call its
        // startForeground() method within five seconds of starting (typically in onStartCommand()).
        startForeground(
            ONGOING_NOTIFICATION_ID,  // Notification ID cannot be 0.
            createNotification("Launching evaluation pipeline…")
        )

        serviceIOScope.launch(Dispatchers.Default) {
            System.loadLibrary("nym_jni")

            // sets up logging on Rust side
            topLevelInit(applicationContext.filesDir.absolutePath)

            // Create new client
            var backoffMillis = 1L
            while (true) {
                try {
                    nymInit(NEW_CLIENT_ID, port = NYM_RUN_PORT)
                    val clientAddress = getAddress(NEW_CLIENT_ID)
                    withContext(Dispatchers.IO) {
                        keyStringValuePairRepository.put(
                            listOf(
                                RUNNING_CLIENT_ID_KSVP_KEY to NEW_CLIENT_ID,
                                RUNNING_CLIENT_ADDRESS_KSVP_KEY to clientAddress,
                            )
                        )
                    }
                    break
                } catch (e: RuntimeException) {
                    e.printStackTrace()
                    Log.i(TAG, "ADBFGS nymInit failed, backing off: backoffMillis=$backoffMillis")
                    delay(backoffMillis)
                    backoffMillis *= 2
                }
            }

            Log.i(TAG, "enqueuing work... (inside coroutine Main/UI)")
            withContext(Dispatchers.IO) {
                Log.i(TAG, "enqueuing work... (inside coroutine, inside withContext IO)")
                keyStringValuePairRepository.put(
                    listOf(
                        NYM_RUN_STATE_KSVP_KEY to NymRunState.SETTING_UP.name
                    )
                )
            }

            // It will shutdown after MAX_MESSAGES messages have been sent through the Nym mixnet
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                applicationContext.startForegroundService(
                    Intent(
                        applicationContext,
                        NymRunForegroundService::class.java
                    ).apply {
                        putExtra(
                            NYMRUN_FOREGROUND_SERVICE_CLIENT_ID_EXTRA_KEY,
                            NEW_CLIENT_ID
                        )
                    }
                )
            } else {
                applicationContext.startService(
                    Intent(
                        applicationContext,
                        NymRunForegroundService::class.java
                    ).apply {
                        putExtra(
                            NYMRUN_FOREGROUND_SERVICE_CLIENT_ID_EXTRA_KEY,
                            NEW_CLIENT_ID
                        )
                    }
                )
            }

            stopSelf(startId)
        }

        return START_NOT_STICKY
    }


    override fun onBind(intent: Intent?): IBinder? {
        // Returning null as this ForegroundService does not support binding
        return null
    }

    /**
     * If the service is started and is long-running, the system lowers its position in the list of
     * background tasks over time, and the service becomes highly susceptible to killing—if your
     * service is started, you must design it to gracefully handle restarts by the system. If the
     * system kills your service, it restarts it as soon as resources become available, but this
     * also depends on the value that you return from onStartCommand().
     */
    override fun onDestroy() {
        supervisorJob.cancel()  // NB: Doesn't wait for completion of its child jobs.
        Log.w(TAG, "Exiting ADBForegroundService process")
        exitProcess(0)
    }

    //////////////////////////////////////////////////
    // FOREGROUND SERVICE NOTIFICATIONS BOILERPLATE //
    //////////////////////////////////////////////////

    private val notificationManager by lazy {
        applicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    }

    private fun createNotification(
        notificationText: String, ongoing: Boolean = true
    ): Notification {
        val channelId =
            applicationContext.getString(R.string.adb_foreground_service_notification_channel_id)
        val notificationTitle =
            applicationContext.getString(R.string.adb_foreground_service_notification_title)

        // Create a Notification channel
        // SDK_INT is always >=26 (Android O) as specified in manifest, so need to create a
        // notification channel
        // Update: Nope, now supporting min SDK 21
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            createChannel()
        }

        return NotificationCompat.Builder(applicationContext, channelId)
            .setContentTitle(notificationTitle)
            .setTicker(notificationTitle)
            .setContentText(notificationText)
            .setSmallIcon(R.drawable.ic_baseline_cloud_sync_24)
            .setOngoing(ongoing)
            .setForegroundServiceBehavior(FOREGROUND_SERVICE_IMMEDIATE)
            .build()
        // DONE: Is non-deterministic behaviour of notifications still present? Yes, but cannot control.
        // DONE (Clarify): Non-deterministic behaviour, notification doesn't always show up:
        // It's because I'm sending notifications too frequently, sometimes I see
        // "notifications silenced" (something to this effect) in Logcat.
    }

    // It's safe to call this repeatedly because creating an existing notification channel is a no-op.
    @RequiresApi(Build.VERSION_CODES.O)
    private fun createChannel() {
        val channelId =
            applicationContext.getString(R.string.adb_foreground_service_notification_channel_id)
        val channelName =
            applicationContext.getString(R.string.adb_foreground_service_notification_channel_name)
        val channelImportance = NotificationManager.IMPORTANCE_HIGH
        val channelDescription =
            applicationContext.getString(R.string.adb_foreground_service_notification_channel_description)

        val channel = NotificationChannel(channelId, channelName, channelImportance).apply {
            description = channelDescription
        }
        // Register the channel with the system; you can't change the importance or other
        // notification behaviours after this
        notificationManager.createNotificationChannel(channel)
    }
}